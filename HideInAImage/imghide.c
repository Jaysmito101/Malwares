#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/stat.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#define MAX_DATA_SIZE 4096 * 4096

void print_usage(const char* message)
{
	printf("%s\n", message);
	printf("USAGE:\n");
	printf("      imghide <mode> <input image> [data type] [data]\n");
	printf("      Modes:\n");
	printf("                  [1] /h for hiding\n");
	printf("                  [2] /u for unhiding\n\n");
	printf("      Data types:\n");
	printf("                  [1] /f for file\n");
	printf("                  [2] /t for text\n");
	exit(0);
}

unsigned char* read_file(const char* filename, size_t* size)
{
	struct stat info;
	if (stat(filename, &info) != 0)
		print_usage("ERROR: Failed to get stats of file");
	FILE* fd = fopen(filename, "rb");
	if(fd == NULL)
		print_usage("ERROR: Failed to open file");	
	unsigned char* data = malloc(info.st_size);
	if(data == NULL)
		print_usage("ERROR: Failed to allocate memory");
	size_t blocks_read = fread(data, info.st_size, 1, fd);
	fclose(fd);
	if(blocks_read != 1)
	{
		free(data);
		print_usage("ERROR: Failed to read file.");
	}
	*size = info.st_size;	
	return data;		
}

void print_image(unsigned char* image_data, int image_size)
{
	for(int i = 0 ; i < image_size ; i++)
	{
		unsigned char r = image_data[i * 4 + 0];
		unsigned char g = image_data[i * 4 + 1];
		unsigned char b = image_data[i * 4 + 2];
		unsigned char a = image_data[i * 4 + 3];
		if(a == 0)
			printf("(%d, %d, %d, %d)\n", r, g, b, a);
	}
}

bool hide_in_image(unsigned char* image_data, int image_size, unsigned char* data, int data_size)
{
	int offset = 0;
	for(int i = 0 ; i < image_size ; i++)
	{
		unsigned char r = image_data[i * 4 + 0];
		unsigned char g = image_data[i * 4 + 1];
		unsigned char b = image_data[i * 4 + 2];
		unsigned char a = image_data[i * 4 + 3];
		if(a == 0)
		{
			if(data_size == 0)
			{
				image_data[i * 4 + 0] = -1;
				return true;	
			}
			image_data[i * 4 + 0] = *(data + offset + 0);

			if(data_size == 1)
			{
				image_data[i * 4 + 1] = -1;
				return true;
			}
			image_data[i * 4 + 1] = *(data + offset + 1);

			if(data_size == 2)
			{
				image_data[i * 4 + 2] = -1;
				return true;
			}
			image_data[i * 4 + 2] = *(data + offset + 2);

			offset += 3;
			data_size -= 3;
		}
	}
	return data_size == 0;
}

bool unhide_from_image(unsigned char* image_data, int image_size, unsigned char* data, int* data_size)
{
	unsigned char* data_c = data;
	*data_size = 0;
	for(int i = 0 ; i < image_size ; i++)
	{
		unsigned char r = image_data[i * 4 + 0];
		unsigned char g = image_data[i * 4 + 1];
		unsigned char b = image_data[i * 4 + 2];
		unsigned char a = image_data[i * 4 + 3];
		if(a == 0)
		{
			if(*data_size > MAX_DATA_SIZE - 2 || r == -1 || g == -1 || b == -1)
			{
				return true;
			}
			*(data_c + 0) = image_data[i * 4 + 0];
			*(data_c + 1) = image_data[i * 4 + 1];
			*(data_c + 2) = image_data[i * 4 + 2];
			data_c += 3;
			*data_size = *data_size + 3;
		}
	}
	return true;
}

void main(int argc, char** argv)
{
	unsigned char* data = NULL;
	size_t data_size;
	unsigned char* image_data = NULL;
	int width, height, channels;
	bool require_free_data = false;
	bool hide_image = false;

	if(strcmp(argv[1], "/h") == 0)
		hide_image = true;
	else if(strcmp(argv[1], "/u") == 0)
		hide_image = false;
	else
		print_usage("ERROR: Invalid mode.");

	if(hide_image)
	{
		if(argc != 5)
			print_usage("ERROR: Invalid number of arguments.");
	}
	else
	{
		if(argc != 3)
			print_usage("ERROR: Invalid number of arguments.");
	}

	if(hide_image)
	{
		if(strcmp(argv[3], "/t") == 0)
		{
			data = argv[4];
			data_size = strlen(argv[4]);
		}
		else if(strcmp(argv[3], "/f") == 0)
		{
			data = read_file(argv[4], &data_size);
			require_free_data = true;
		}
		else
			print_usage("ERROR: Invalid data type.");
	}


	if(hide_image)
	{
		if(data_size > MAX_DATA_SIZE)
		{
			if(require_free_data)
				free(data);
			print_usage("ERROR: Max data size exceeded.");
		}
	}
	else
	{
		if(require_free_data)
			free(data);
		data = malloc(MAX_DATA_SIZE);
		if(data == NULL)
			print_usage("ERROR: Failed to allocate memory.");
		require_free_data = true;
	}

	image_data = stbi_load(argv[2], &width, &height, &channels, 0);	
	
	if(image_data == NULL)
	{
		if(require_free_data)
			free(data);
		print_usage("ERROR: Failed to load image.");
	}
	
	if(channels != 4)
	{
		if(require_free_data)
			free(data);
		print_usage("ERROR: Input image is not a 4 channel image.");
	}

	int total_pixels = width * height;

	bool sucess = false;

	if(hide_image)
		sucess = hide_in_image(image_data, total_pixels, data, (int)data_size);
	else
		sucess = unhide_from_image(image_data, total_pixels, data, &data_size);
	

	if(sucess)
		stbi_write_png(argv[2], width, height, channels, image_data, width * channels);


	if(!sucess)
	{
		print_usage("ERROR: Data size mismatch in image and data size.");
		if(require_free_data)
			free(data);
	}

	if(!hide_image)
	{
		printf("INFO: Extracted %ld bytes from %s\n", data_size, argv[2]);
		printf("INFO: Saved extracted file in extracted.bin");
		FILE *write_ptr;
		write_ptr = fopen("extracted.bin", "wb");
		fwrite(data, data_size, 1, write_ptr);
		fclose(write_ptr);
	}
	else
	{
		printf("INFO: Hidden %ld bytes in %s", data_size, argv[2]);
		stbi_image_free(image_data);
	}

	if(require_free_data)
		free(data);
}